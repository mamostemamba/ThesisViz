/**
 * TikZ-to-JSON Parser
 *
 * Parses TikZ code (from \begin{tikzpicture} to \end{tikzpicture})
 * into a structured TikZDocument for the post-processing editor.
 *
 * Handles common patterns generated by the TikZ agent:
 *   \node[options] (name) at (pos) {text};
 *   \draw[options] (A) -- (B);
 *   \coordinate (name) at (pos);
 *
 * Everything else is preserved as raw elements for round-trip fidelity.
 */

import type {
  TikZDocument,
  TikZElement,
  TikZNode,
  TikZDraw,
  TikZCoordinate,
  TikZRaw,
  TikZOption,
} from "./types";

let _nextId = 0;
function genId(): string {
  return `el_${_nextId++}`;
}

/** Reset the ID counter (useful for tests). */
export function resetIdCounter(): void {
  _nextId = 0;
}

// ---------------------------------------------------------------------------
// Bracket / brace helpers
// ---------------------------------------------------------------------------

/**
 * Find the matching close bracket/brace/paren for the one at `start`.
 * Returns the index of the closing character, or -1 if not found.
 * Handles nested brackets of the same type and skips TikZ comments.
 * When searching for ] or ), nested {} groups are skipped entirely
 * to avoid miscounting brackets inside brace-delimited values.
 */
function findMatchingClose(s: string, start: number): number {
  const open = s[start];
  const close =
    open === "{" ? "}" : open === "[" ? "]" : open === "(" ? ")" : "";
  if (!close) return -1;

  let depth = 0;
  for (let i = start; i < s.length; i++) {
    const ch = s[i];

    // Skip TeX comments (% to end of line) — but not escaped \%
    if (ch === "%" && (i === 0 || s[i - 1] !== "\\")) {
      while (i < s.length && s[i] !== "\n") i++;
      continue;
    }

    // When looking for ] or ), skip balanced {} entirely
    if (open !== "{" && ch === "{") {
      const j = findMatchingClose(s, i);
      if (j === -1) return -1;
      i = j;
      continue;
    }

    if (ch === open) depth++;
    else if (ch === close) {
      depth--;
      if (depth === 0) return i;
    }
  }
  return -1;
}

/**
 * Extract the content between balanced delimiters starting at `pos`.
 * Returns { content, end } where `end` is the index after the closing delimiter.
 */
function extractBalanced(
  s: string,
  pos: number
): { content: string; end: number } | null {
  const closeIdx = findMatchingClose(s, pos);
  if (closeIdx === -1) return null;
  return { content: s.slice(pos + 1, closeIdx), end: closeIdx + 1 };
}

// ---------------------------------------------------------------------------
// Options parser
// ---------------------------------------------------------------------------

/**
 * Parse a TikZ options string (the content between [ and ]) into
 * an array of { key, value } pairs.
 *
 * Splits by commas at brace-depth 0.
 * For each part, splits at the first `=`.
 */
export function parseOptions(optStr: string): TikZOption[] {
  if (!optStr.trim()) return [];

  const parts: string[] = [];
  let current = "";
  let depth = 0;

  for (const ch of optStr) {
    if (ch === "{") depth++;
    if (ch === "}") depth--;
    if (ch === "," && depth === 0) {
      parts.push(current.trim());
      current = "";
    } else {
      current += ch;
    }
  }
  if (current.trim()) parts.push(current.trim());

  return parts
    .filter((p) => p.length > 0)
    .map((part) => {
      const eqIdx = part.indexOf("=");
      if (eqIdx === -1) {
        return { key: part.trim(), value: "" };
      }
      return {
        key: part.slice(0, eqIdx).trim(),
        value: part.slice(eqIdx + 1).trim(),
      };
    });
}

// ---------------------------------------------------------------------------
// Statement splitter
// ---------------------------------------------------------------------------

/**
 * Split the tikzpicture body into individual statements.
 *
 * Semicolons at brace/bracket depth 0 terminate statements.
 * Comment-only lines and blank lines become their own statements.
 * \begin{...}...\end{...} blocks are grouped as single statements.
 */
function splitStatements(body: string): string[] {
  const stmts: string[] = [];
  let current = "";
  let depth = 0; // tracks { } nesting
  let bracketDepth = 0; // tracks [ ] nesting
  let inComment = false;

  for (let i = 0; i < body.length; i++) {
    const ch = body[i];

    // Handle comment start
    if (ch === "%" && !inComment && (i === 0 || body[i - 1] !== "\\")) {
      inComment = true;
      current += ch;
      continue;
    }

    // Handle newline — ends comments, may split comment-only lines
    if (ch === "\n") {
      if (inComment) {
        inComment = false;
        // If the accumulated line is comment-only, emit it
        const trimmed = current.trim();
        if (
          trimmed.startsWith("%") &&
          depth === 0 &&
          bracketDepth === 0
        ) {
          stmts.push(trimmed);
          current = "";
          continue;
        }
      }
      current += ch;
      continue;
    }

    if (inComment) {
      current += ch;
      continue;
    }

    // Track nesting
    if (ch === "{") depth++;
    if (ch === "}") {
      depth--;
      // When a brace group closes at depth 0, check for commands
      // that don't use ; as terminator (\def, \begin{...}, \end{...}).
      // Emit them as standalone statements so they don't swallow the
      // next semicolon-terminated statement.
      if (depth === 0 && bracketDepth === 0) {
        current += ch;
        const trimmed = current.trim();

        // \def\name{value} — emit immediately
        if (/^\\def\\/.test(trimmed)) {
          stmts.push(trimmed);
          current = "";
          continue;
        }

        // \end{...} — emit immediately
        if (/^\\end\{/.test(trimmed)) {
          stmts.push(trimmed);
          current = "";
          continue;
        }

        // \begin{...} — also consume mandatory {arg} and optional [options]
        if (/^\\begin\{/.test(trimmed)) {
          let j = i + 1;
          // Consume optional mandatory {arg} (e.g. \begin{pgfonlayer}{background})
          while (j < body.length && /\s/.test(body[j])) j++;
          if (j < body.length && body[j] === "{") {
            const closeIdx = findMatchingClose(body, j);
            if (closeIdx !== -1) {
              current += body.slice(i + 1, closeIdx + 1);
              i = closeIdx;
              j = closeIdx + 1;
            }
          }
          // Consume optional [options]
          while (j < body.length && /\s/.test(body[j])) j++;
          if (j < body.length && body[j] === "[") {
            const closeIdx = findMatchingClose(body, j);
            if (closeIdx !== -1) {
              current += body.slice(i + 1, closeIdx + 1);
              i = closeIdx;
            }
          }
          stmts.push(current.trim());
          current = "";
          continue;
        }

        // Other brace-closed constructs: just continue accumulating
        continue;
      }
    }
    if (ch === "[") bracketDepth++;
    if (ch === "]") bracketDepth--;

    current += ch;

    // Semicolon at depth 0 terminates a statement
    if (ch === ";" && depth === 0 && bracketDepth === 0) {
      stmts.push(current.trim());
      current = "";
    }
  }

  // Remaining content
  if (current.trim()) {
    stmts.push(current.trim());
  }

  return stmts.filter((s) => s.length > 0);
}

// ---------------------------------------------------------------------------
// Individual statement parsers
// ---------------------------------------------------------------------------

function skipWS(s: string, pos: number): number {
  while (pos < s.length && /\s/.test(s[pos])) pos++;
  return pos;
}

/**
 * Try to parse a \node statement.
 *
 * Patterns:
 *   \node[opts] (name) at (pos) {text};
 *   \node[opts] (name) {text};
 *   \node[opts] at (pos) {text};
 *   \node[opts] {text};
 */
function tryParseNode(stmt: string): TikZNode | null {
  const nodeMatch = stmt.match(/^\\node\s*/);
  if (!nodeMatch) return null;

  let pos = nodeMatch[0].length;

  // Optional [options]
  let options: TikZOption[] = [];
  if (stmt[pos] === "[") {
    const bal = extractBalanced(stmt, pos);
    if (bal) {
      options = parseOptions(bal.content);
      pos = bal.end;
    }
  }

  pos = skipWS(stmt, pos);

  // Check for (name) vs at (position)
  let name = "";
  let position = "";

  if (pos < stmt.length && stmt[pos] === "(") {
    // Could be name or part of "at (...)"
    // If preceded by "at", it's a position. Otherwise it's a name.
    const bal = extractBalanced(stmt, pos);
    if (bal) {
      name = bal.content.trim();
      pos = bal.end;
    }
  }

  pos = skipWS(stmt, pos);

  // Check for "at (position)"
  const atMatch = stmt.slice(pos).match(/^at\s*/);
  if (atMatch) {
    pos += atMatch[0].length;
    if (pos < stmt.length && stmt[pos] === "(") {
      const bal = extractBalanced(stmt, pos);
      if (bal) {
        position = bal.content.trim();
        pos = bal.end;
      }
    }
  } else if (name && !stmt.slice(pos).match(/^\{/) && stmt[pos] === "(") {
    // Edge case: \node at (pos) {text} — name was actually empty,
    // what we parsed as name might be position from "at" we missed.
    // This shouldn't happen with our logic above.
  }

  // Handle case: \node at (pos) — no name, what we parsed as "name" is wrong
  // Re-check: if the original had "at" right after \node[opts]
  // This is already handled — if "at" comes first, we wouldn't enter the name branch

  pos = skipWS(stmt, pos);

  // Options may appear after (name) or after at (pos): \node (n) [opts] {text}
  if (options.length === 0 && pos < stmt.length && stmt[pos] === "[") {
    const bal = extractBalanced(stmt, pos);
    if (bal) {
      options = parseOptions(bal.content);
      pos = bal.end;
    }
    pos = skipWS(stmt, pos);
  }

  // {content}
  let content = "";
  if (pos < stmt.length && stmt[pos] === "{") {
    const bal = extractBalanced(stmt, pos);
    if (bal) {
      content = bal.content;
      pos = bal.end;
    }
  }

  return {
    type: "node",
    id: genId(),
    name,
    options,
    position,
    content,
    raw: stmt,
  };
}

/**
 * Try to parse \node at (...) — without name.
 * Re-parse to handle: \node[opts] at (pos) {text};
 * The main tryParseNode already handles this via the "at" check after name.
 * But we need to handle the case where there's no parenthesized name
 * and "at" comes directly after options.
 */

/**
 * Try to parse a \draw, \fill, \filldraw, or \path statement.
 */
function tryParseDraw(stmt: string): TikZDraw | null {
  const drawMatch = stmt.match(/^\\(draw|fill|filldraw|path)\s*/);
  if (!drawMatch) return null;

  const command = drawMatch[1];
  let pos = drawMatch[0].length;

  // Optional [options]
  let options: TikZOption[] = [];
  if (stmt[pos] === "[") {
    const bal = extractBalanced(stmt, pos);
    if (bal) {
      options = parseOptions(bal.content);
      pos = bal.end;
    }
  }

  // Everything after options until ; is the path
  let path = stmt.slice(pos).trim();
  if (path.endsWith(";")) path = path.slice(0, -1).trim();

  return {
    type: "draw",
    id: genId(),
    command,
    options,
    path,
    raw: stmt,
  };
}

/**
 * Try to parse a \coordinate statement.
 * Pattern: \coordinate (name) at (pos);
 */
function tryParseCoordinate(stmt: string): TikZCoordinate | null {
  const coordMatch = stmt.match(/^\\coordinate\s*/);
  if (!coordMatch) return null;

  let pos = coordMatch[0].length;

  // (name)
  let name = "";
  if (stmt[pos] === "(") {
    const bal = extractBalanced(stmt, pos);
    if (bal) {
      name = bal.content.trim();
      pos = bal.end;
    }
  }

  pos = skipWS(stmt, pos);

  // at (position)
  let position = "";
  const atMatch = stmt.slice(pos).match(/^at\s*/);
  if (atMatch) {
    pos += atMatch[0].length;
    if (pos < stmt.length && stmt[pos] === "(") {
      const bal = extractBalanced(stmt, pos);
      if (bal) {
        position = bal.content.trim();
        pos = bal.end;
      }
    }
  }

  return {
    type: "coordinate",
    id: genId(),
    name,
    position,
    raw: stmt,
  };
}

/**
 * Parse a single statement into a TikZElement.
 */
function parseStatement(stmt: string): TikZElement {
  // Skip blank / comment-only lines
  const trimmed = stmt.trim();
  if (!trimmed || trimmed.startsWith("%")) {
    return { type: "raw", id: genId(), content: trimmed };
  }

  // Handle \node at (...) — "at" right after options, no name
  // We need special handling because tryParseNode checks for ( first
  const atNodeMatch = trimmed.match(/^\\node\s*(\[[^\]]*\])?\s*at\s/);
  if (atNodeMatch) {
    // Parse as node but skip the name step
    const nodeMatch = trimmed.match(/^\\node\s*/);
    if (nodeMatch) {
      let pos = nodeMatch[0].length;
      let options: TikZOption[] = [];
      if (trimmed[pos] === "[") {
        const bal = extractBalanced(trimmed, pos);
        if (bal) {
          options = parseOptions(bal.content);
          pos = bal.end;
        }
      }
      pos = skipWS(trimmed, pos);
      let position = "";
      const atM = trimmed.slice(pos).match(/^at\s*/);
      if (atM) {
        pos += atM[0].length;
        if (pos < trimmed.length && trimmed[pos] === "(") {
          const bal = extractBalanced(trimmed, pos);
          if (bal) {
            position = bal.content.trim();
            pos = bal.end;
          }
        }
      }
      pos = skipWS(trimmed, pos);
      let content = "";
      if (pos < trimmed.length && trimmed[pos] === "{") {
        const bal = extractBalanced(trimmed, pos);
        if (bal) {
          content = bal.content;
        }
      }
      return {
        type: "node",
        id: genId(),
        name: "",
        options,
        position,
        content,
        raw: trimmed,
      };
    }
  }

  // Try node
  const node = tryParseNode(trimmed);
  if (node) return node;

  // Try draw/fill/filldraw/path
  // But exclude \path with "let" (complex calc expressions)
  if (
    !trimmed.startsWith("\\path") ||
    !trimmed.includes("let")
  ) {
    const draw = tryParseDraw(trimmed);
    if (draw) return draw;
  }

  // Try coordinate
  const coord = tryParseCoordinate(trimmed);
  if (coord) return coord;

  // Fallback: raw
  return { type: "raw", id: genId(), content: trimmed };
}

// ---------------------------------------------------------------------------
// Main parser
// ---------------------------------------------------------------------------

/**
 * Parse TikZ code into a structured TikZDocument.
 *
 * Expects code that starts with \begin{tikzpicture} and ends with
 * \end{tikzpicture}. Also handles bare tikzpicture body without wrappers.
 */
export function parseTikZ(code: string): TikZDocument {
  resetIdCounter();

  // Extract tikzpicture body and global options
  let globalOptions = "";
  let body = code;

  const beginMatch = code.match(/\\begin\{tikzpicture\}\s*/);
  if (beginMatch) {
    let pos = beginMatch.index! + beginMatch[0].length;

    // Extract global options [...]
    if (code[pos] === "[") {
      const bal = findMatchingClose(code, pos);
      if (bal !== -1) {
        globalOptions = code.slice(pos + 1, bal);
        pos = bal + 1;
      }
    }

    // Find \end{tikzpicture}
    const endMatch = code.indexOf("\\end{tikzpicture}");
    if (endMatch !== -1) {
      body = code.slice(pos, endMatch).trim();
    } else {
      body = code.slice(pos).trim();
    }
  }

  // Split body into statements
  const stmts = splitStatements(body);

  // Parse each statement
  const elements: TikZElement[] = stmts.map((s) => parseStatement(s));

  return { globalOptions, elements };
}
